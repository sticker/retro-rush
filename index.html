<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
    <title>レトロラッシュ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: 'Courier New', monospace;
        overflow: hidden;
        touch-action: manipulation;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }
      
      #game-container {
        position: relative;
        width: 100%;
        height: 100vh;
        max-width: 360px;
        max-height: 640px;
        margin: 0 auto;
      }
      
      canvas {
        border: 2px solid #333;
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }
      
      /* CRT効果のオーバーレイ */
      #crt-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.1;
        background: repeating-linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.15),
          rgba(0, 0, 0, 0.15) 1px,
          transparent 1px,
          transparent 2px
        );
        animation: scanlines 8s linear infinite;
      }
      
      @keyframes scanlines {
        0% { background-position: 0 0; }
        100% { background-position: 0 10px; }
      }
      
      /* 画面のちらつき効果 */
      @keyframes flicker {
        0% { opacity: 0.97; }
        50% { opacity: 1; }
        100% { opacity: 0.98; }
      }
      
      #game-container.flicker {
        animation: flicker 0.15s infinite;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="crt-overlay"></div>
    </div>
    <script>
      // 振動フィードバック管理
      class HapticManager {
        static isSupported() {
          // Vibration APIのサポートチェック
          return 'vibrate' in navigator && typeof navigator.vibrate === 'function';
        }
        
        static vibrate(pattern) {
          try {
            if (this.isSupported()) {
              // iOSでは動作しないが、エラーは出さない
              const result = navigator.vibrate(pattern);
              if (!result) {
                console.log('Vibration not supported on this device');
              }
            }
          } catch (e) {
            // エラーは静かに処理（iOSなど非対応環境のため）
            console.log('Vibration not available:', e.message);
          }
        }
        
        static success() {
          this.vibrate([0, 20, 30, 20]);
        }
        
        static fail() {
          this.vibrate([0, 50]);
        }
        
        static perfect() {
          this.vibrate([0, 10, 10, 10, 10, 10]);
        }
        
        static tap() {
          this.vibrate([10]); // シンプルな10ms振動
        }
        
        static countdown() {
          this.vibrate([30]);
        }
      }

      // UI定数
      const UI_CONFIG = {
        // 親指が届きやすい範囲（画面下部60%）
        THUMB_ZONE: {
          startY: 0.4,
          endY: 0.9
        },
        // タップエリアの最小サイズ
        MIN_TAP_SIZE: 48,
        // タップエリア間の間隔
        TAP_PADDING: 8,
        // 画面端の無効エリア
        DEAD_ZONE: 16,
        // 連続タップ防止時間
        TAP_COOLDOWN: 100,
        // 高速画面遷移
        TRANSITION: {
          showResult: 500,
          autoNext: 300,
          betweenGames: 200
        }
      };

      // レトロエフェクト管理
      class RetroEffects {
        static addFlicker(scene) {
          scene.time.addEvent({
            delay: 100,
            callback: () => {
              const container = document.getElementById('game-container');
              container.classList.toggle('flicker');
              setTimeout(() => container.classList.toggle('flicker'), 50);
            },
            loop: true
          });
        }
        
        static createParticles(scene, x, y, type) {
          const particles = {
            success: { color: 0x00ff00, count: 10, speed: 100 },
            perfect: { color: 0xff00ff, count: 20, speed: 150 },
            fail: { color: 0xff0000, count: 5, speed: 50 }
          };
          
          const config = particles[type];
          if (!config) return;
          
          for (let i = 0; i < config.count; i++) {
            const particle = scene.add.circle(x, y, 2, config.color);
            const angle = (Math.PI * 2 * i) / config.count;
            
            scene.tweens.add({
              targets: particle,
              x: x + Math.cos(angle) * config.speed,
              y: y + Math.sin(angle) * config.speed,
              alpha: 0,
              duration: 600,
              ease: 'Cubic.easeOut',
              onComplete: () => particle.destroy()
            });
          }
        }
        
        static bounceEffect(scene, target) {
          scene.tweens.add({
            targets: target,
            scaleX: 1.2,
            scaleY: 1.2,
            duration: 100,
            ease: 'Cubic.easeOut',
            yoyo: true
          });
        }
      }

      // ゲーム全体の状態管理
      let gameState = {
        totalScore: 0,
        currentGame: 0,
        gamesCompleted: 0,
        lives: 3,
        highScore: localStorage.getItem('retroRushHighScore') || 0
      };

      // ベースシーンクラス（共通機能）
      class BaseGameScene extends Phaser.Scene {
        createThumbZoneUI() {
          const height = this.game.config.height;
          const thumbStartY = height * UI_CONFIG.THUMB_ZONE.startY;
          
          // 操作エリアの視覚的表示
          const thumbZone = this.add.rectangle(
            this.game.config.width / 2,
            thumbStartY + (height * UI_CONFIG.THUMB_ZONE.endY - thumbStartY) / 2,
            this.game.config.width - UI_CONFIG.DEAD_ZONE * 2,
            height * UI_CONFIG.THUMB_ZONE.endY - thumbStartY,
            0x000000,
            0
          );
          thumbZone.setStrokeStyle(1, 0x333333, 0.3);
          
          return thumbZone;
        }
        
        showQuickFeedback(text, color, x, y) {
          const feedback = this.add.text(x, y, text, {
            fontSize: '16px',
            fill: Phaser.Display.Color.IntegerToColor(color).rgba,
            fontFamily: 'Courier New'
          }).setOrigin(0.5);
          
          this.tweens.add({
            targets: feedback,
            alpha: 0,
            y: y - 20,
            duration: 600,
            ease: 'Cubic.easeOut',
            onComplete: () => feedback.destroy()
          });
        }
        
        createCountdown(callback) {
          const centerX = this.game.config.width / 2;
          const centerY = this.game.config.height / 2;
          let count = 3;
          
          const countdownText = this.add.text(centerX, centerY, count.toString(), {
            fontSize: '48px',
            color: '#ffff00',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);
          
          const countdownTimer = this.time.addEvent({
            delay: 500,
            callback: () => {
              count--;
              HapticManager.countdown();
              
              if (count > 0) {
                countdownText.setText(count.toString());
                RetroEffects.bounceEffect(this, countdownText);
              } else if (count === 0) {
                countdownText.setText('GO!');
                countdownText.setStyle({ color: '#00ff00' });
                RetroEffects.bounceEffect(this, countdownText);
              } else {
                countdownText.destroy();
                callback();
              }
            },
            repeat: 4
          });
        }
      }

      // メインメニューシーン
      class MainMenuScene extends Phaser.Scene {
        constructor() {
          super({ key: 'MainMenuScene' });
        }

        create() {
          // レトロエフェクト追加
          RetroEffects.addFlicker(this);
          
          // タッチイベントのデバッグ（削除）
          
          // タイトル画面の作成
          this.add.text(this.game.config.width / 2, 100, 'レトロラッシュ', {
            fontSize: '28px',
            fill: '#00ff00',
            fontFamily: 'Courier New',
            stroke: '#005500',
            strokeThickness: 2
          }).setOrigin(0.5);

          this.add.text(this.game.config.width / 2, 140, 'RETRO RUSH', {
            fontSize: '20px',
            fill: '#ffff00',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // スコア表示
          this.add.text(this.game.config.width / 2, 200, `最高スコア: ${gameState.highScore}`, {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // 親指エリアにスタートボタン配置（シンプルに作り直す）
          const thumbStartY = this.game.config.height * UI_CONFIG.THUMB_ZONE.startY;
          
          const startButton = this.add.rectangle(
            this.game.config.width / 2, 
            thumbStartY + 80, 
            160, 
            60, 
            0x00ff00
          );
          startButton.setStrokeStyle(2, 0x00aa00);
          
          const startText = this.add.text(
            this.game.config.width / 2, 
            thumbStartY + 80, 
            'スタート', {
            fontSize: '20px',
            fill: '#000000',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);
          
          // スタートボタンのインタラクティブ設定
          startButton.setInteractive({ useHandCursor: true });
          
          // 重複イベントを防ぐため、一度だけ登録
          startButton.once('pointerdown', () => {
            HapticManager.tap();
            startButton.setFillStyle(0x00aa00);
            RetroEffects.bounceEffect(this, startButton);
            
            // ゲーム開始
            this.startGame();
          });
          
          startButton.on('pointerup', () => {
            startButton.setFillStyle(0x00ff00);
          });
          
          startButton.on('pointerover', () => {
            startButton.setFillStyle(0x00dd00);
          });
          
          startButton.on('pointerout', () => {
            startButton.setFillStyle(0x00ff00);
          });

          // 操作説明
          this.add.text(this.game.config.width / 2, thumbStartY + 140, 'タップ・スワイプで操作', {
            fontSize: '14px',
            fill: '#888888',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // レトロな点滅効果
          this.time.addEvent({
            delay: 500,
            callback: () => {
              startText.visible = !startText.visible;
            },
            loop: true
          });
          
          // 星背景
          this.createStarField();
        }

        startGame() {
          console.log('=== startGame called ===');
          console.log('Current scene:', this.scene.key);
          
          // ゲーム状態をリセット
          gameState.totalScore = 0;
          gameState.currentGame = 0;
          gameState.gamesCompleted = 0;
          gameState.lives = 3;

          console.log('Game state reset:', gameState);
          console.log('About to start MoleWhackScene...');
          
          // 次のゲームを開始
          try {
            console.log('this.scene:', this.scene);
            console.log('this.scene.start:', this.scene.start);
            this.scene.start('MoleWhackScene');
            console.log('MoleWhackScene started successfully');
          } catch (error) {
            console.error('Error starting MoleWhackScene:', error);
            console.error('Error stack:', error.stack);
          }
        }
        
        createStarField() {
          for (let i = 0; i < 30; i++) {
            const x = Phaser.Math.Between(0, this.game.config.width);
            const y = Phaser.Math.Between(0, this.game.config.height * 0.3);
            const star = this.add.circle(x, y, 1, 0xffffff);

            this.tweens.add({
              targets: star,
              alpha: { from: 0.3, to: 0.8 },
              duration: Phaser.Math.Between(1000, 3000),
              yoyo: true,
              repeat: -1,
              delay: Phaser.Math.Between(0, 2000)
            });
          }
        }
      }

      // モグラタタキゲーム
      class MoleWhackScene extends BaseGameScene {
        constructor() {
          super({ key: 'MoleWhackScene' });
          console.log('MoleWhackScene constructor called');
          this.lastTapTime = 0;
        }

        create() {
          console.log('=== MoleWhackScene create() called ===');
          this.molesHit = 0;
          this.timeLeft = 5;
          this.moles = [];
          this.holes = [];

          // UI作成
          this.scoreText = this.add.text(20, 20, `スコア: ${gameState.totalScore}`, {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New',
            stroke: '#000000',
            strokeThickness: 2
          });

          this.timeText = this.add.text(20, 45, `残り: ${this.timeLeft}秒`, {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New',
            stroke: '#000000',
            strokeThickness: 2
          });

          this.targetText = this.add.text(this.game.config.width / 2, 80, 'モグラを5匹タップせよ！', {
            fontSize: '14px',
            fill: '#ffff00',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // 親指ゾーンの表示
          const thumbZone = this.createThumbZoneUI();
          
          // 穴の配置（3x3グリッド）- 親指エリア内に配置
          const thumbStartY = this.game.config.height * UI_CONFIG.THUMB_ZONE.startY;
          const gridStartY = thumbStartY + 40;
          
          for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
              const x = 60 + col * 80;
              const y = gridStartY + row * 80;

              // 穴（黒い円）
              const hole = this.add.circle(x, y, 30, 0x333333);
              hole.setStrokeStyle(2, 0x222222);
              this.holes.push(hole);

              // モグラを単純な円として作成（Containerは使わない）
              const mole = this.add.circle(x, y, 25, 0x8b4513);
              mole.setStrokeStyle(2, 0x654321);
              mole.setVisible(false);
              
              // インタラクティブ設定
              mole.setInteractive({ useHandCursor: true });
              
              // クリックイベント
              mole.on('pointerdown', () => {
                if (mole.visible) {
                  this.hitMole(mole);
                }
              });
              
              this.moles.push(mole);
            }
          }

          // カウントダウン後にゲーム開始
          this.createCountdown(() => {
            // タイマー開始
            this.timer = this.time.addEvent({
              delay: 1000,
              callback: this.updateTimer,
              callbackScope: this,
              loop: true
            });

            // モグラ出現タイマー
            this.moleTimer = this.time.addEvent({
              delay: 700,
              callback: this.spawnMole,
              callbackScope: this,
              loop: true
            });

            this.spawnMole(); // 最初のモグラを即座に出現
          });
        }

        spawnMole() {
          // ランダムな穴からモグラを出現
          const availableMoles = this.moles.filter((mole) => !mole.visible);
          if (availableMoles.length > 0) {
            const mole = Phaser.Utils.Array.GetRandom(availableMoles);
            mole.setVisible(true);
            
            // 出現アニメーション
            mole.setScale(0);
            this.tweens.add({
              targets: mole,
              scaleX: 1,
              scaleY: 1,
              duration: 200,
              ease: 'Back.easeOut'
            });

            // 1.2秒後に自動的に隠れる
            this.time.delayedCall(1200, () => {
              if (mole.visible) {
                this.tweens.add({
                  targets: mole,
                  scaleX: 0,
                  scaleY: 0,
                  duration: 200,
                  ease: 'Back.easeIn',
                  onComplete: () => mole.setVisible(false)
                });
              }
            });
          }
        }

        hitMole(mole) {
          const currentTime = Date.now();
          if (currentTime - this.lastTapTime < UI_CONFIG.TAP_COOLDOWN) return;
          this.lastTapTime = currentTime;
          
          HapticManager.tap();
          mole.setVisible(false);
          this.molesHit++;
          gameState.totalScore += 100;

          this.scoreText.setText(`スコア: ${gameState.totalScore}`);
          
          // ヒットエフェクト
          RetroEffects.createParticles(this, mole.x, mole.y, 'success');
          this.showQuickFeedback('HIT!', 0x00ff00, mole.x, mole.y - 30);

          if (this.molesHit >= 5) {
            HapticManager.perfect();
            this.gameComplete(true);
          }
        }

        updateTimer() {
          this.timeLeft--;
          this.timeText.setText(`残り: ${this.timeLeft}秒`);

          if (this.timeLeft <= 0) {
            this.gameComplete(false);
          }
        }

        gameComplete(success) {
          if (this.timer) this.timer.remove();
          if (this.moleTimer) this.moleTimer.remove();

          if (success) {
            gameState.gamesCompleted++;
            HapticManager.success();
            const text = this.add.text(this.game.config.width / 2, this.game.config.height / 2, 'クリア！', {
              fontSize: '32px',
              fill: '#00ff00',
              fontFamily: 'Courier New',
              stroke: '#003300',
              strokeThickness: 3
            }).setOrigin(0.5);
            RetroEffects.bounceEffect(this, text);
          } else {
            gameState.lives--;
            HapticManager.fail();
            this.add.text(this.game.config.width / 2, this.game.config.height / 2, '失敗...', {
              fontSize: '32px',
              fill: '#ff0000',
              fontFamily: 'Courier New',
              stroke: '#330000',
              strokeThickness: 3
            }).setOrigin(0.5);
          }

          // 高速遷移
          this.input.once('pointerdown', () => this.nextGame());
          this.time.delayedCall(UI_CONFIG.TRANSITION.showResult, () => {
            this.nextGame();
          });
        }

        nextGame() {
          gameState.currentGame++;
          if (gameState.lives > 0) {
            this.scene.start('RhythmJumpScene');
          } else {
            this.scene.start('GameOverScene');
          }
        }
      }

      // リズムジャンプゲーム
      class RhythmJumpScene extends BaseGameScene {
        constructor() {
          super({ key: 'RhythmJumpScene' });
          this.lastTapTime = 0;
        }

        create() {
          this.successes = 0;
          this.timeLeft = 8;
          this.barPosition = 0;
          this.barDirection = 1;
          this.beatCount = 0;

          // UI作成
          this.scoreText = this.add.text(20, 20, `スコア: ${gameState.totalScore}`, {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New',
            stroke: '#000000',
            strokeThickness: 2
          });

          this.successText = this.add.text(20, 45, '成功: ', {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New',
            stroke: '#000000',
            strokeThickness: 2
          });

          // 成功数表示（星マーク）
          this.updateSuccessDisplay();

          this.add.text(this.game.config.width / 2, 80, '音楽に合わせてタップ！', {
            fontSize: '14px',
            fill: '#ffff00',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          this.add.text(this.game.config.width / 2, 100, '3回成功でクリア', {
            fontSize: '12px',
            fill: '#ffffff',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // キャラクター（上部に配置）
          this.add.text(this.game.config.width / 2, 150, 'ドット君', {
            fontSize: '14px',
            fill: '#ffffff',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          this.character = this.add.text(this.game.config.width / 2, 170, '(｡･ω･｡)', {
            fontSize: '20px',
            fill: '#ffff00',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // 親指ゾーンの表示
          const thumbZone = this.createThumbZoneUI();
          const thumbStartY = this.game.config.height * UI_CONFIG.THUMB_ZONE.startY;

          // リズムバー背景（親指エリア内）
          this.barBg = this.add.rectangle(this.game.config.width / 2, thumbStartY + 60, 240, 40, 0x333333);
          this.barBg.setStrokeStyle(2, 0x222222);

          // 判定ライン（中央）
          this.judgeLine = this.add.rectangle(this.game.config.width / 2, thumbStartY + 60, 30, 40, 0x00ff00);
          this.judgeLine.setStrokeStyle(2, 0x00aa00);

          // 動くバー
          this.movingBar = this.add.rectangle(60, thumbStartY + 60, 25, 35, 0xff0000);
          this.movingBar.setStrokeStyle(2, 0xaa0000);

          // タップエリア（親指エリア全体）
          const tapArea = this.add.rectangle(
            this.game.config.width / 2, 
            thumbStartY + 120, 
            this.game.config.width - UI_CONFIG.DEAD_ZONE * 2, 
            150, 
            0x000000, 
            0.1
          );
          tapArea.setStrokeStyle(1, 0x444444);
          tapArea.setInteractive();
          tapArea.on('pointerdown', () => this.checkTiming());

          this.add.text(this.game.config.width / 2, thumbStartY + 120, 'タップ！', {
            fontSize: '18px',
            fill: '#888888',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // カウントダウン後にゲーム開始
          this.createCountdown(() => {
            // タイマー
            this.timer = this.time.addEvent({
              delay: 1000,
              callback: this.updateTimer,
              callbackScope: this,
              loop: true
            });

            // バー移動
            this.barTimer = this.time.addEvent({
              delay: 16, // 60FPS
              callback: this.moveBar,
              callbackScope: this,
              loop: true
            });

            // ビート音タイマー（1秒間隔）
            this.beatTimer = this.time.addEvent({
              delay: 1000,
              callback: this.playBeat,
              callbackScope: this,
              loop: true
            });
          });
        }

        moveBar() {
          this.barPosition += this.barDirection * 2.5;

          if (this.barPosition >= 120 || this.barPosition <= -120) {
            this.barDirection *= -1;
          }

          this.movingBar.x = this.game.config.width / 2 + this.barPosition;
        }

        playBeat() {
          this.beatCount++;
          // ビート表示
          const beatText = this.add.text(this.game.config.width - 40, 45, '♪', {
            fontSize: '20px',
            fill: '#ff00ff',
            fontFamily: 'Courier New'
          });

          this.tweens.add({
            targets: beatText,
            alpha: 0,
            x: this.game.config.width - 50,
            duration: 800,
            onComplete: () => beatText.destroy()
          });
        }

        checkTiming() {
          const currentTime = Date.now();
          if (currentTime - this.lastTapTime < UI_CONFIG.TAP_COOLDOWN) return;
          this.lastTapTime = currentTime;
          
          const distance = Math.abs(this.barPosition);
          const thumbStartY = this.game.config.height * UI_CONFIG.THUMB_ZONE.startY;

          if (distance < 15) {
            // パーフェクト判定
            this.successes++;
            gameState.totalScore += 200;
            HapticManager.perfect();
            this.showQuickFeedback('パーフェクト！', 0x00ff00, this.game.config.width / 2, thumbStartY + 20);
            RetroEffects.createParticles(this, this.movingBar.x, this.movingBar.y, 'perfect');
            
            // キャラクターアニメーション
            this.tweens.add({
              targets: this.character,
              scaleX: 1.3,
              scaleY: 0.7,
              duration: 100,
              yoyo: true,
              ease: 'Cubic.easeOut'
            });
          } else if (distance < 30) {
            // グッド判定
            this.successes++;
            gameState.totalScore += 100;
            HapticManager.success();
            this.showQuickFeedback('ナイス！', 0xffff00, this.game.config.width / 2, thumbStartY + 20);
            RetroEffects.createParticles(this, this.movingBar.x, this.movingBar.y, 'success');
          } else {
            HapticManager.fail();
            this.showQuickFeedback('ミス...', 0xff0000, this.game.config.width / 2, thumbStartY + 20);
            
            // キャラクターを悲しくする
            this.character.setText('(｡>﹏<｡)');
            this.time.delayedCall(500, () => this.character.setText('(｡･ω･｡)'));
          }

          this.scoreText.setText(`スコア: ${gameState.totalScore}`);
          this.updateSuccessDisplay();

          if (this.successes >= 3) {
            this.gameComplete(true);
          }
        }

        updateSuccessDisplay() {
          let stars = '';
          for (let i = 0; i < 3; i++) {
            stars += i < this.successes ? '★' : '☆';
          }
          this.successText.setText(`成功: ${stars}`);
        }

        updateTimer() {
          this.timeLeft--;

          if (this.timeLeft <= 0) {
            this.gameComplete(false);
          }
        }

        gameComplete(success) {
          if (this.timer) this.timer.remove();
          if (this.barTimer) this.barTimer.remove();
          if (this.beatTimer) this.beatTimer.remove();

          if (success) {
            gameState.gamesCompleted++;
            HapticManager.success();
            const text = this.add.text(this.game.config.width / 2, this.game.config.height / 2, 'クリア！', {
              fontSize: '32px',
              fill: '#00ff00',
              fontFamily: 'Courier New',
              stroke: '#003300',
              strokeThickness: 3
            }).setOrigin(0.5);
            RetroEffects.bounceEffect(this, text);
          } else {
            gameState.lives--;
            HapticManager.fail();
            this.add.text(this.game.config.width / 2, this.game.config.height / 2, '失敗...', {
              fontSize: '32px',
              fill: '#ff0000',
              fontFamily: 'Courier New',
              stroke: '#330000',
              strokeThickness: 3
            }).setOrigin(0.5);
          }

          // 高速遷移
          this.input.once('pointerdown', () => this.nextGame());
          this.time.delayedCall(UI_CONFIG.TRANSITION.showResult, () => {
            this.nextGame();
          });
        }

        nextGame() {
          gameState.currentGame++;
          if (gameState.lives > 0) {
            this.scene.start('ColorMatchScene');
          } else {
            this.scene.start('GameOverScene');
          }
        }
      }

      // カラーマッチゲーム
      class ColorMatchScene extends BaseGameScene {
        constructor() {
          super({ key: 'ColorMatchScene' });
        }

        create() {
          this.successes = 0;
          this.timeLeft = 7;
          this.blocks = [];
          this.colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00]; // 赤、青、緑、黄
          this.colorNames = ['赤', '青', '緑', '黄'];

          // UI作成
          this.scoreText = this.add.text(20, 20, `スコア: ${gameState.totalScore}`, {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New',
            stroke: '#000000',
            strokeThickness: 2
          });

          this.timeText = this.add.text(20, 45, `残り: ${this.timeLeft}秒`, {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New',
            stroke: '#000000',
            strokeThickness: 2
          });

          this.successText = this.add.text(20, 70, '成功: ', {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New',
            stroke: '#000000',
            strokeThickness: 2
          });
          this.updateSuccessDisplay();

          this.add.text(this.game.config.width / 2, 100, '同じ色の穴にスワイプ！', {
            fontSize: '14px',
            fill: '#ffff00',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          this.add.text(this.game.config.width / 2, 120, '5個成功でクリア', {
            fontSize: '12px',
            fill: '#ffffff',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // 親指ゾーンの表示
          const thumbZone = this.createThumbZoneUI();
          const thumbStartY = this.game.config.height * UI_CONFIG.THUMB_ZONE.startY;

          // 穴の作成（親指エリア内の下部）
          this.holes = [];
          const holeY = thumbStartY + 180;
          
          for (let i = 0; i < 4; i++) {
            const x = 50 + i * 70;

            const hole = this.add.rectangle(x, holeY, 50, 50, this.colors[i]);
            hole.setStrokeStyle(3, Phaser.Display.Color.IntegerToColor(this.colors[i]).darken(30).color);
            hole.colorIndex = i;
            this.holes.push(hole);

            // 色名表示
            this.add.text(x, holeY + 35, this.colorNames[i], {
              fontSize: '12px',
              fill: '#ffffff',
              fontFamily: 'Courier New',
              stroke: '#000000',
              strokeThickness: 2
            }).setOrigin(0.5);
          }

          // ブロック落下エリア
          this.dropZone = this.add.rectangle(
            this.game.config.width / 2,
            thumbStartY + 90,
            this.game.config.width - 40,
            140,
            0x000000,
            0
          );
          this.dropZone.setStrokeStyle(1, 0x444444, 0.5);

          // カウントダウン後にゲーム開始
          this.createCountdown(() => {
            // タイマー開始
            this.timer = this.time.addEvent({
              delay: 1000,
              callback: this.updateTimer,
              callbackScope: this,
              loop: true
            });

            // ブロック生成タイマー
            this.blockTimer = this.time.addEvent({
              delay: 1000,
              callback: this.spawnBlock,
              callbackScope: this,
              loop: true
            });

            this.spawnBlock(); // 最初のブロックを即座に生成

            // スワイプ検出の設定
            this.input.on('pointerdown', this.startSwipe, this);
            this.input.on('pointermove', this.updateSwipe, this);
            this.input.on('pointerup', this.endSwipe, this);
          });
        }

        spawnBlock() {
          const colorIndex = Phaser.Math.Between(0, 3);
          const x = this.game.config.width / 2;
          const thumbStartY = this.game.config.height * UI_CONFIG.THUMB_ZONE.startY;
          const y = thumbStartY + 20;

          const block = this.add.circle(x, y, 20, this.colors[colorIndex]);
          block.setStrokeStyle(2, Phaser.Display.Color.IntegerToColor(this.colors[colorIndex]).darken(30).color);
          block.colorIndex = colorIndex;
          block.startY = y;
          block.isDragging = false;
          this.blocks.push(block);

          // ブロックを下に移動
          block.fallTween = this.tweens.add({
            targets: block,
            y: thumbStartY + 160,
            duration: 2500,
            ease: 'Linear',
            onComplete: () => {
              this.removeBlock(block);
              HapticManager.fail();
              this.showQuickFeedback('落下！', 0xff0000, block.x, block.y);
            }
          });
        }

        startSwipe(pointer) {
          const thumbStartY = this.game.config.height * UI_CONFIG.THUMB_ZONE.startY;
          
          // 親指エリア内でのみスワイプ開始
          if (pointer.y < thumbStartY) return;
          
          this.swipeStartX = pointer.x;
          this.swipeStartY = pointer.y;
          
          // タップしたブロックを取得
          const targetBlock = this.getClosestBlock(pointer.x, pointer.y);
          if (targetBlock && !targetBlock.isDragging) {
            this.currentBlock = targetBlock;
            targetBlock.isDragging = true;
            if (targetBlock.fallTween) {
              targetBlock.fallTween.pause();
            }
            HapticManager.tap();
            RetroEffects.bounceEffect(this, targetBlock);
          }
        }
        
        updateSwipe(pointer) {
          if (this.currentBlock && this.currentBlock.isDragging) {
            // ブロックを指に追従させる
            this.currentBlock.x = pointer.x;
            this.currentBlock.y = pointer.y;
          }
        }

        endSwipe(pointer) {
          if (!this.currentBlock) return;

          const block = this.currentBlock;
          block.isDragging = false;

          // どの穴の上にあるかチェック
          let targetHole = null;
          let minDistance = Infinity;
          
          this.holes.forEach(hole => {
            const distance = Phaser.Math.Distance.Between(block.x, block.y, hole.x, hole.y);
            if (distance < 50 && distance < minDistance) {
              minDistance = distance;
              targetHole = hole;
            }
          });

          if (targetHole) {
            // 穴に吸い込まれるアニメーション
            this.tweens.add({
              targets: block,
              x: targetHole.x,
              y: targetHole.y,
              scale: 0,
              duration: 200,
              ease: 'Power2',
              onComplete: () => {
                // 色判定
                if (block.colorIndex === targetHole.colorIndex) {
                  this.successes++;
                  gameState.totalScore += 150;
                  HapticManager.success();
                  this.showQuickFeedback('正解！', 0x00ff00, targetHole.x, targetHole.y - 30);
                  RetroEffects.createParticles(this, targetHole.x, targetHole.y, 'success');
                  
                  if (this.successes >= 5) {
                    this.gameComplete(true);
                  }
                } else {
                  HapticManager.fail();
                  this.showQuickFeedback('間違い！', 0xff0000, targetHole.x, targetHole.y - 30);
                  RetroEffects.createParticles(this, targetHole.x, targetHole.y, 'fail');
                }

                this.scoreText.setText(`スコア: ${gameState.totalScore}`);
                this.updateSuccessDisplay();
                this.removeBlock(block);
              }
            });
          } else {
            // 落下を再開
            if (block.fallTween) {
              block.fallTween.resume();
            }
          }

          this.currentBlock = null;
        }

        getClosestBlock(x, y) {
          let closest = null;
          let minDistance = Infinity;

          this.blocks.forEach((block) => {
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            if (distance < minDistance && distance < 40) {
              minDistance = distance;
              closest = block;
            }
          });

          return closest;
        }

        removeBlock(block) {
          const index = this.blocks.indexOf(block);
          if (index > -1) {
            this.blocks.splice(index, 1);
            if (block.fallTween) {
              block.fallTween.stop();
            }
            block.destroy();
          }
        }

        updateSuccessDisplay() {
          let stars = '';
          for (let i = 0; i < 5; i++) {
            stars += i < this.successes ? '★' : '☆';
          }
          this.successText.setText(`成功: ${stars}`);
        }

        updateTimer() {
          this.timeLeft--;
          this.timeText.setText(`残り: ${this.timeLeft}秒`);

          if (this.timeLeft <= 0) {
            this.gameComplete(false);
          }
        }

        gameComplete(success) {
          if (this.timer) this.timer.remove();
          if (this.blockTimer) this.blockTimer.remove();

          // 残りのブロックを削除
          this.blocks.forEach((block) => {
            if (block.fallTween) block.fallTween.stop();
            block.destroy();
          });
          this.blocks = [];

          if (success) {
            gameState.gamesCompleted++;
            HapticManager.success();
            const text = this.add.text(this.game.config.width / 2, this.game.config.height / 2, 'クリア！', {
              fontSize: '32px',
              fill: '#00ff00',
              fontFamily: 'Courier New',
              stroke: '#003300',
              strokeThickness: 3
            }).setOrigin(0.5);
            RetroEffects.bounceEffect(this, text);
          } else {
            gameState.lives--;
            HapticManager.fail();
            this.add.text(this.game.config.width / 2, this.game.config.height / 2, '失敗...', {
              fontSize: '32px',
              fill: '#ff0000',
              fontFamily: 'Courier New',
              stroke: '#330000',
              strokeThickness: 3
            }).setOrigin(0.5);
          }

          // 高速遷移
          this.input.once('pointerdown', () => this.nextGame());
          this.time.delayedCall(UI_CONFIG.TRANSITION.showResult, () => {
            this.nextGame();
          });
        }

        nextGame() {
          // 3つのゲームが終了したら、最初から繰り返す（難易度上昇）
          if (gameState.lives > 0) {
            if (gameState.currentGame >= 2) {
              gameState.currentGame = 0;
              this.scene.start('MoleWhackScene');
            } else {
              this.scene.start('GameOverScene');
            }
          } else {
            this.scene.start('GameOverScene');
          }
        }
      }

      // ゲームオーバーシーン
      class GameOverScene extends Phaser.Scene {
        constructor() {
          super({ key: 'GameOverScene' });
        }

        create() {
          // ハイスコア更新
          if (gameState.totalScore > gameState.highScore) {
            gameState.highScore = gameState.totalScore;
            localStorage.setItem('retroRushHighScore', gameState.highScore);
          }
          
          // ゲームオーバー表示
          this.add.text(this.game.config.width / 2, 100, 'GAME OVER', {
            fontSize: '32px',
            fill: '#ff0000',
            fontFamily: 'Courier New',
            stroke: '#330000',
            strokeThickness: 3
          }).setOrigin(0.5);

          // 結果表示
          this.add.text(this.game.config.width / 2, 150, `最終スコア: ${gameState.totalScore}`, {
            fontSize: '20px',
            fill: '#ffffff',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          this.add.text(this.game.config.width / 2, 180, `クリアゲーム数: ${gameState.gamesCompleted}`, {
            fontSize: '16px',
            fill: '#ffffff',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          // ランク表示
          let rank = 'D';
          let rankColor = 0x888888;
          if (gameState.totalScore >= 2000) { rank = 'S'; rankColor = 0xff00ff; }
          else if (gameState.totalScore >= 1500) { rank = 'A'; rankColor = 0xffff00; }
          else if (gameState.totalScore >= 1000) { rank = 'B'; rankColor = 0x00ff00; }
          else if (gameState.totalScore >= 500) { rank = 'C'; rankColor = 0x00ffff; }

          const rankText = this.add.text(this.game.config.width / 2, 220, `ランク: ${rank}`, {
            fontSize: '24px',
            fill: Phaser.Display.Color.IntegerToColor(rankColor).rgba,
            fontFamily: 'Courier New',
            stroke: '#000000',
            strokeThickness: 2
          }).setOrigin(0.5);
          
          // ランクに応じたエフェクト
          if (rank === 'S' || rank === 'A') {
            this.tweens.add({
              targets: rankText,
              scaleX: 1.1,
              scaleY: 1.1,
              duration: 500,
              yoyo: true,
              repeat: -1,
              ease: 'Sine.easeInOut'
            });
          }

          // 親指エリアにボタン配置
          const thumbStartY = this.game.config.height * UI_CONFIG.THUMB_ZONE.startY;
          
          // リトライボタン
          const retryButton = this.add.rectangle(this.game.config.width / 2, thumbStartY + 40, 140, 50, 0x00ff00);
          retryButton.setStrokeStyle(2, 0x00aa00);
          this.add.text(this.game.config.width / 2, thumbStartY + 40, 'もう一度', {
            fontSize: '18px',
            fill: '#000000',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          retryButton.setInteractive({ useHandCursor: true });
          retryButton.on('pointerdown', () => {
            HapticManager.tap();
            RetroEffects.bounceEffect(this, retryButton);
            this.time.delayedCall(100, () => this.scene.start('MainMenuScene'));
          });

          // メニューに戻るボタン
          const menuButton = this.add.rectangle(this.game.config.width / 2, thumbStartY + 100, 140, 50, 0x888888);
          menuButton.setStrokeStyle(2, 0x555555);
          this.add.text(this.game.config.width / 2, thumbStartY + 100, 'メニューへ', {
            fontSize: '18px',
            fill: '#ffffff',
            fontFamily: 'Courier New'
          }).setOrigin(0.5);

          menuButton.setInteractive({ useHandCursor: true });
          menuButton.on('pointerdown', () => {
            HapticManager.tap();
            RetroEffects.bounceEffect(this, menuButton);
            this.time.delayedCall(100, () => this.scene.start('MainMenuScene'));
          });

          // レトロな背景効果
          this.createStarField();
          
          // ハイスコア更新時の演出
          if (gameState.totalScore === gameState.highScore && gameState.totalScore > 0) {
            const newRecord = this.add.text(this.game.config.width / 2, 260, 'NEW RECORD!', {
              fontSize: '20px',
              fill: '#ff00ff',
              fontFamily: 'Courier New',
              stroke: '#330033',
              strokeThickness: 2
            }).setOrigin(0.5);
            
            this.tweens.add({
              targets: newRecord,
              alpha: { from: 1, to: 0.3 },
              duration: 400,
              yoyo: true,
              repeat: -1
            });
          }
        }

        createStarField() {
          for (let i = 0; i < 30; i++) {
            const x = Phaser.Math.Between(0, this.game.config.width);
            const y = Phaser.Math.Between(0, this.game.config.height);
            const star = this.add.circle(x, y, Phaser.Math.Between(1, 2), 0xffffff);

            this.tweens.add({
              targets: star,
              alpha: { from: 0.3, to: 0.8 },
              duration: Phaser.Math.Between(1000, 3000),
              yoyo: true,
              repeat: -1,
              delay: Phaser.Math.Between(0, 2000)
            });
          }
        }
      }

      // ゲーム設定
      const config = {
        type: Phaser.AUTO,
        width: 360,
        height: 640,
        backgroundColor: '#000000',
        parent: 'game-container',
        scene: [
          MainMenuScene,
          MoleWhackScene,
          RhythmJumpScene,
          ColorMatchScene,
          GameOverScene
        ],
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH
        },
        render: {
          pixelArt: true,
          antialias: false
        },
        input: {
          activePointers: 3,
          touch: {
            target: null,
            capture: false
          }
        }
      };

      // ゲーム開始
      const game = new Phaser.Game(config);
    </script>
  </body>
</html>